!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("axios"),require("qs"),require("lodash-es"),require("generate-avatar"),require("js-base64"),require("sweetalert2"),require("moment"),require("moment/dist/locale/zh-cn")):"function"==typeof define&&define.amd?define(["exports","axios","qs","lodash-es","generate-avatar","js-base64","sweetalert2","moment","moment/dist/locale/zh-cn"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)["@herodotus/core"]={},t.Axios,t.Qs,t.LodashEs,t.GenerateAvatar,t.JsBase64,t.Sweetalert2,t.Moment)}(this,function(t,e,n,r,o,i,s,a){"use strict";function c(t){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(t)for(const n in t)if("default"!==n){const r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:!0,get:()=>t[n]})}return e.default=t,Object.freeze(e)}const u=c(r);var l=(t=>(t[t.URL_ENCODED=0]="URL_ENCODED",t[t.MULTI_PART=1]="MULTI_PART",t[t.TEXT=2]="TEXT",t[t.JSON=3]="JSON",t))(l||{}),h=(t=>(t.GET="GET",t.POST="POST",t.PUT="PUT",t.DELETE="DELETE",t))(h||{}),f=(t=>(t[t.FORBIDDEN=0]="FORBIDDEN",t[t.ENABLE=1]="ENABLE",t[t.LOCKING=2]="LOCKING",t[t.EXPIRED=3]="EXPIRED",t))(f||{});let d=new Map;const g=t=>[t.method,t.url].join("&");class AxiosCanceler{addPending(t){this.removePending(t);const n=g(t);t.cancelToken=t.cancelToken||new e.CancelToken(t=>{d.has(n)||d.set(n,t)})}removeAllPending(){d.forEach(t=>{t&&r.isFunction(t)&&t()}),d.clear()}removePending(t){const e=g(t);if(d.has(e)){const t=d.get(e);t&&t(e),d.delete(e)}}reset(){d=new Map}}class AvatarUtilities{static instance=new AvatarUtilities;constructor(){}static getInstance(){return this.instance}generate(t){return`data:image/svg+xml;utf8,${o.generateFromString(t)}`}}const p=AvatarUtilities.getInstance(),y="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function w(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function m(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function b(t,...e){if(!w(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function E(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.createHasher");m(t.outputLen),m(t.blockLen)}function v(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const A=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),x=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function B(t){if(b(t),A)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=x[t[n]];return e}const P=48,S=57,U=65,O=70,I=97,R=102;function H(t){return t>=P&&t<=S?t-P:t>=U&&t<=O?t-(U-10):t>=I&&t<=R?t-(I-10):void 0}function C(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(A)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,i=0;o<n;o++,i+=2){const e=H(t.charCodeAt(i)),n=H(t.charCodeAt(i+1));if(void 0===e||void 0===n){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}r[o]=16*e+n}return r}function T(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}(t)),b(t),t}function L(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];b(n),e+=n.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const e=t[r];n.set(e,o),o+=e.length}return n}let N=class Hash{};function q(t=32){if(y&&"function"==typeof y.getRandomValues)return y.getRandomValues(new Uint8Array(t));if(y&&"function"==typeof y.randomBytes)return Uint8Array.from(y.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const k=BigInt(0),j=BigInt(1);function F(t,e=""){if("boolean"!=typeof t){throw new Error((e&&`"${e}"`)+"expected boolean, got type="+typeof t)}return t}function V(t,e,n=""){const r=w(t),o=t?.length,i=void 0!==e;if(!r||i&&o!==e){throw new Error((n&&`"${n}" `)+"expected Uint8Array"+(i?` of length ${e}`:"")+", got "+(r?`length=${o}`:"type="+typeof t))}return t}function K(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function D(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?k:BigInt("0x"+t)}function _(t){return D(B(t))}function Z(t){return b(t),D(B(Uint8Array.from(t).reverse()))}function M(t,e){return C(t.toString(16).padStart(2*e,"0"))}function z(t,e){return M(t,e).reverse()}function G(t,e,n){let r;if("string"==typeof e)try{r=C(e)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else{if(!w(e))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(t+" of length "+n+" expected, got "+o);return r}const $=t=>"bigint"==typeof t&&k<=t;function Y(t,e,n,r){if(!function(t,e,n){return $(t)&&$(e)&&$(n)&&e<=t&&t<n}(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function X(t){let e;for(e=0;t>k;t>>=j,e+=1);return e}const W=t=>(j<<BigInt(t))-j;function J(t,e,n={}){if(!t||"object"!=typeof t)throw new Error("expected valid options object");function r(e,n,r){const o=t[e];if(r&&void 0===o)return;const i=typeof o;if(i!==n||null===o)throw new Error(`param "${e}" is invalid: expected ${n}, got ${i}`)}Object.entries(e).forEach(([t,e])=>r(t,e,!1)),Object.entries(n).forEach(([t,e])=>r(t,e,!0))}function Q(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(void 0!==o)return o;const i=t(n,...r);return e.set(n,i),i}}const tt=B,et=L,nt=K,rt=D,ot=M;let it=class HMAC extends N{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,E(t);const n=T(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,o=new Uint8Array(r);o.set(n.length>r?t.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=t.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),function(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}(o)}update(t){return v(this),this.iHash.update(t),this}digestInto(t){v(this),b(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=r,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const st=(t,e,n)=>new it(t,e).update(n).digest();st.create=(t,e)=>new it(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const at=BigInt(0),ct=BigInt(1),ut=BigInt(2),lt=BigInt(3),ht=BigInt(4),ft=BigInt(5),dt=BigInt(7),gt=BigInt(8),pt=BigInt(9),yt=BigInt(16);function wt(t,e){const n=t%e;return n>=at?n:e+n}function mt(t,e){if(t===at)throw new Error("invert: expected non-zero number");if(e<=at)throw new Error("invert: expected positive modulus, got "+e);let n=wt(t,e),r=e,o=at,i=ct;for(;n!==at;){const t=r%n,e=o-i*(r/n);r=n,n=t,o=i,i=e}if(r!==ct)throw new Error("invert: does not exist");return wt(o,e)}function bt(t,e,n){if(!t.eql(t.sqr(e),n))throw new Error("Cannot find square root")}function Et(t,e){const n=(t.ORDER+ct)/ht,r=t.pow(e,n);return bt(t,r,e),r}function vt(t,e){const n=(t.ORDER-ft)/gt,r=t.mul(e,ut),o=t.pow(r,n),i=t.mul(e,o),s=t.mul(t.mul(i,ut),o),a=t.mul(i,t.sub(s,t.ONE));return bt(t,a,e),a}function At(t){if(t<lt)throw new Error("sqrt is not defined for small field");let e=t-ct,n=0;for(;e%ut===at;)e/=ut,n++;let r=ut;const o=Ot(t);for(;1===St(o,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n)return Et;let i=o.pow(r,e);const s=(e+ct)/ut;return function(t,r){if(t.is0(r))return r;if(1!==St(t,r))throw new Error("Cannot find square root");let o=n,a=t.mul(t.ONE,i),c=t.pow(r,e),u=t.pow(r,s);for(;!t.eql(c,t.ONE);){if(t.is0(c))return t.ZERO;let e=1,n=t.sqr(c);for(;!t.eql(n,t.ONE);)if(e++,n=t.sqr(n),e===o)throw new Error("Cannot find square root");const r=ct<<BigInt(o-e-1),i=t.pow(a,r);o=e,a=t.sqr(i),c=t.mul(c,a),u=t.mul(u,i)}return u}}function xt(t){return t%ht===lt?Et:t%gt===ft?vt:t%yt===pt?function(t){const e=Ot(t),n=At(t),r=n(e,e.neg(e.ONE)),o=n(e,r),i=n(e,e.neg(r)),s=(t+dt)/yt;return(t,e)=>{let n=t.pow(e,s),a=t.mul(n,r);const c=t.mul(n,o),u=t.mul(n,i),l=t.eql(t.sqr(a),e),h=t.eql(t.sqr(c),e);n=t.cmov(n,a,l),a=t.cmov(u,c,h);const f=t.eql(t.sqr(a),e),d=t.cmov(n,a,f);return bt(t,d,e),d}}(t):At(t)}const Bt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Pt(t,e,n=!1){const r=new Array(e.length).fill(n?t.ZERO:void 0),o=e.reduce((e,n,o)=>t.is0(n)?e:(r[o]=e,t.mul(e,n)),t.ONE),i=t.inv(o);return e.reduceRight((e,n,o)=>t.is0(n)?e:(r[o]=t.mul(e,r[o]),t.mul(e,n)),i),r}function St(t,e){const n=(t.ORDER-ct)/ut,r=t.pow(e,n),o=t.eql(r,t.ONE),i=t.eql(r,t.ZERO),s=t.eql(r,t.neg(t.ONE));if(!o&&!i&&!s)throw new Error("invalid Legendre symbol result");return o?1:i?0:-1}function Ut(t,e){void 0!==e&&m(e);const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function Ot(t,e,n=!1,r={}){if(t<=at)throw new Error("invalid field: expected ORDER > 0, got "+t);let o,i,s,a=!1;if("object"==typeof e&&null!=e){if(r.sqrt||n)throw new Error("cannot specify opts in two arguments");const t=e;t.BITS&&(o=t.BITS),t.sqrt&&(i=t.sqrt),"boolean"==typeof t.isLE&&(n=t.isLE),"boolean"==typeof t.modFromBytes&&(a=t.modFromBytes),s=t.allowedLengths}else"number"==typeof e&&(o=e),r.sqrt&&(i=r.sqrt);const{nBitLength:c,nByteLength:u}=Ut(t,o);if(u>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let l;const h=Object.freeze({ORDER:t,isLE:n,BITS:c,BYTES:u,MASK:W(c),ZERO:at,ONE:ct,allowedLengths:s,create:e=>wt(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return at<=e&&e<t},is0:t=>t===at,isValidNot0:t=>!h.is0(t)&&h.isValid(t),isOdd:t=>(t&ct)===ct,neg:e=>wt(-e,t),eql:(t,e)=>t===e,sqr:e=>wt(e*e,t),add:(e,n)=>wt(e+n,t),sub:(e,n)=>wt(e-n,t),mul:(e,n)=>wt(e*n,t),pow:(t,e)=>function(t,e,n){if(n<at)throw new Error("invalid exponent, negatives unsupported");if(n===at)return t.ONE;if(n===ct)return e;let r=t.ONE,o=e;for(;n>at;)n&ct&&(r=t.mul(r,o)),o=t.sqr(o),n>>=ct;return r}(h,t,e),div:(e,n)=>wt(e*mt(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>mt(e,t),sqrt:i||(e=>(l||(l=xt(t)),l(h,e))),toBytes:t=>n?z(t,u):M(t,u),fromBytes:(e,r=!0)=>{if(s){if(!s.includes(e.length)||e.length>u)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+e.length);const t=new Uint8Array(u);t.set(e,n?0:t.length-e.length),e=t}if(e.length!==u)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+e.length);let o=n?Z(e):_(e);if(a&&(o=wt(o,t)),!r&&!h.isValid(o))throw new Error("invalid field element: outside of range 0..ORDER");return o},invertBatch:t=>Pt(h,t),cmov:(t,e,n)=>n?e:t});return Object.freeze(h)}function It(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Rt(t){const e=It(t);return e+Math.ceil(e/2)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ht=BigInt(0),Ct=BigInt(1);function Tt(t,e){const n=e.negate();return t?n:e}function Lt(t,e){const n=Pt(t.Fp,e.map(t=>t.Z));return e.map((e,r)=>t.fromAffine(e.toAffine(n[r])))}function Nt(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function qt(t,e){Nt(t,e);const n=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:W(t),maxNumber:n,shiftBy:BigInt(t)}}function kt(t,e,n){const{windowSize:r,mask:o,maxNumber:i,shiftBy:s}=n;let a=Number(t&o),c=t>>s;a>r&&(a-=i,c+=Ct);const u=e*r;return{nextN:c,offset:u+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:e%2!=0,offsetF:u}}const jt=new WeakMap,Ft=new WeakMap;function Vt(t){return Ft.get(t)||1}function Kt(t){if(t!==Ht)throw new Error("invalid wNAF")}class wNAF{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let r=t;for(;e>Ht;)e&Ct&&(n=n.add(r)),r=r.double(),e>>=Ct;return n}precomputeWindow(t,e){const{windows:n,windowSize:r}=qt(e,this.bits),o=[];let i=t,s=i;for(let a=0;a<n;a++){s=i,o.push(s);for(let t=1;t<r;t++)s=s.add(i),o.push(s);i=s.double()}return o}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let r=this.ZERO,o=this.BASE;const i=qt(t,this.bits);for(let s=0;s<i.windows;s++){const{nextN:t,offset:a,isZero:c,isNeg:u,isNegF:l,offsetF:h}=kt(n,s,i);n=t,c?o=o.add(Tt(l,e[h])):r=r.add(Tt(u,e[a]))}return Kt(n),{p:r,f:o}}wNAFUnsafe(t,e,n,r=this.ZERO){const o=qt(t,this.bits);for(let i=0;i<o.windows&&n!==Ht;i++){const{nextN:t,offset:s,isZero:a,isNeg:c}=kt(n,i,o);if(n=t,!a){const t=e[s];r=r.add(c?t.negate():t)}}return Kt(n),r}getPrecomputes(t,e,n){let r=jt.get(e);return r||(r=this.precomputeWindow(e,t),1!==t&&("function"==typeof n&&(r=n(r)),jt.set(e,r))),r}cached(t,e,n){const r=Vt(t);return this.wNAF(r,this.getPrecomputes(r,t,n),e)}unsafe(t,e,n,r){const o=Vt(t);return 1===o?this._unsafeLadder(t,e,r):this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),e,r)}createCache(t,e){Nt(e,this.bits),Ft.set(t,e),jt.delete(t)}hasCache(t){return 1!==Vt(t)}}function Dt(t,e,n,r){!function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}(n,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}(r,e);const o=n.length,i=r.length;if(o!==i)throw new Error("arrays of points and scalars must have equal length");const s=t.ZERO,a=X(BigInt(o));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=W(c),l=new Array(Number(u)+1).fill(s);let h=s;for(let f=Math.floor((e.BITS-1)/c)*c;f>=0;f-=c){l.fill(s);for(let e=0;e<i;e++){const t=r[e],o=Number(t>>BigInt(f)&u);l[o]=l[o].add(n[e])}let t=s;for(let e=l.length-1,n=s;e>0;e--)n=n.add(l[e]),t=t.add(n);if(h=h.add(t),0!==f)for(let e=0;e<c;e++)h=h.double()}return h}function _t(t,e,n){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return function(t){J(t,Bt.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))}(e),e}return Ot(t,{isLE:n})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Zt=(t,e)=>(t+(t>=0?e:-e)/Xt)/e;function Mt(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function zt(t,e){const n={};for(let r of Object.keys(e))n[r]=void 0===t[r]?e[r]:t[r];return F(n.lowS,"lowS"),F(n.prehash,"prehash"),void 0!==n.format&&Mt(n.format),n}class DERErr extends Error{constructor(t=""){super(t)}}const Gt={Err:DERErr,_tlv:{encode:(t,e)=>{const{Err:n}=Gt;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(1&e.length)throw new n("tlv.encode: unpadded data");const r=e.length/2,o=K(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?K(o.length/2|128):"";return K(t)+i+o+e},decode(t,e){const{Err:n}=Gt;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++];let i=0;if(!!(128&o)){const t=127&o;if(!t)throw new n("tlv.decode(long): indefinite length not supported");if(t>4)throw new n("tlv.decode(long): byte length is too big");const s=e.subarray(r,r+t);if(s.length!==t)throw new n("tlv.decode: length bytes not complete");if(0===s[0])throw new n("tlv.decode(long): zero leftmost byte");for(const e of s)i=i<<8|e;if(r+=t,i<128)throw new n("tlv.decode(long): not minimal encoding")}else i=o;const s=e.subarray(r,r+i);if(s.length!==i)throw new n("tlv.decode: wrong value length");return{v:s,l:e.subarray(r+i)}}},_int:{encode(t){const{Err:e}=Gt;if(t<$t)throw new e("integer: negative integers are not allowed");let n=K(t);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=Gt;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return _(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=Gt,o=G("signature",t),{v:i,l:s}=r.decode(48,o);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,i),{v:u,l:l}=r.decode(2,c);if(l.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(a),s:n.decode(u)}},hexFromSig(t){const{_tlv:e,_int:n}=Gt,r=e.encode(2,n.encode(t.r))+e.encode(2,n.encode(t.s));return e.encode(48,r)}},$t=BigInt(0),Yt=BigInt(1),Xt=BigInt(2),Wt=BigInt(3),Jt=BigInt(4);function Qt(t,e){const{BYTES:n}=t;let r;if("bigint"==typeof e)r=e;else{let i=G("private key",e);try{r=t.fromBytes(i)}catch(o){throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof e}`)}}if(!t.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function te(t,e={}){const n=function(t,e,n={},r){if(void 0===r&&(r="edwards"===t),!e||"object"!=typeof e)throw new Error(`expected valid ${t} CURVE object`);for(const a of["p","n","h"]){const t=e[a];if(!("bigint"==typeof t&&t>Ht))throw new Error(`CURVE.${a} must be positive bigint`)}const o=_t(e.p,n.Fp,r),i=_t(e.n,n.Fn,r),s=["Gx","Gy","a","b"];for(const a of s)if(!o.isValid(e[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:o,Fn:i}}("weierstrass",t,e),{Fp:r,Fn:o}=n;let i=n.CURVE;const{h:s,n:a}=i;J(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=e;if(c&&(!r.is0(i.a)||"bigint"!=typeof c.beta||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=ne(r,o);function l(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}const h=e.toBytes||function(t,e,n){const{x:o,y:i}=e.toAffine(),s=r.toBytes(o);if(F(n,"isCompressed"),n){l();return L(ee(!r.isOdd(i)),s)}return L(Uint8Array.of(4),s,r.toBytes(i))},f=e.fromBytes||function(t){V(t,void 0,"Point");const{publicKey:e,publicKeyUncompressed:n}=u,o=t.length,i=t[0],s=t.subarray(1);if(o!==e||2!==i&&3!==i){if(o===n&&4===i){const t=r.BYTES,e=r.fromBytes(s.subarray(0,t)),n=r.fromBytes(s.subarray(t,2*t));if(!g(e,n))throw new Error("bad point: is not on curve");return{x:e,y:n}}throw new Error(`bad point: got length ${o}, expected compressed=${e} or uncompressed=${n}`)}{const t=r.fromBytes(s);if(!r.isValid(t))throw new Error("bad point: is not on curve, wrong x");const e=d(t);let n;try{n=r.sqrt(e)}catch(a){const t=a instanceof Error?": "+a.message:"";throw new Error("bad point: is not on curve, sqrt error"+t)}l();return!(1&~i)!==r.isOdd(n)&&(n=r.neg(n)),{x:t,y:n}}};function d(t){const e=r.sqr(t),n=r.mul(e,t);return r.add(r.add(n,r.mul(t,i.a)),i.b)}function g(t,e){const n=r.sqr(e),o=d(t);return r.eql(n,o)}if(!g(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const p=r.mul(r.pow(i.a,Wt),Jt),y=r.mul(r.sqr(i.b),BigInt(27));if(r.is0(r.add(p,y)))throw new Error("bad curve params: a or b");function w(t,e,n=!1){if(!r.isValid(e)||n&&r.is0(e))throw new Error(`bad point coordinate ${t}`);return e}function m(t){if(!(t instanceof Point))throw new Error("ProjectivePoint expected")}function b(t){if(!c||!c.basises)throw new Error("no endo");return function(t,e,n){const[[r,o],[i,s]]=e,a=Zt(s*t,n),c=Zt(-o*t,n);let u=t-a*r-c*i,l=-a*o-c*s;const h=u<$t,f=l<$t;h&&(u=-u),f&&(l=-l);const d=W(Math.ceil(X(n)/2))+Yt;if(u<$t||u>=d||l<$t||l>=d)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:h,k1:u,k2neg:f,k2:l}}(t,c.basises,o.ORDER)}const E=Q((t,e)=>{const{X:n,Y:o,Z:i}=t;if(r.eql(i,r.ONE))return{x:n,y:o};const s=t.is0();null==e&&(e=s?r.ONE:r.inv(i));const a=r.mul(n,e),c=r.mul(o,e),u=r.mul(i,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw new Error("invZ was invalid");return{x:a,y:c}}),v=Q(t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.Y))return;throw new Error("bad point: ZERO")}const{x:n,y:o}=t.toAffine();if(!r.isValid(n)||!r.isValid(o))throw new Error("bad point: x or y not field elements");if(!g(n,o))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function A(t,e,n,o,i){return n=new Point(r.mul(n.X,t),n.Y,n.Z),e=Tt(o,e),n=Tt(i,n),e.add(n)}class Point{constructor(t,e,n){this.X=w("x",t),this.Y=w("y",e,!0),this.Z=w("z",n),Object.freeze(this)}static CURVE(){return i}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof Point)throw new Error("projective point not allowed");return r.is0(e)&&r.is0(n)?Point.ZERO:new Point(e,n,r.ONE)}static fromBytes(t){const e=Point.fromAffine(f(V(t,void 0,"point")));return e.assertValidity(),e}static fromHex(t){return Point.fromBytes(G("pointHex",t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return P.createCache(this,t),e||this.multiply(Wt),this}assertValidity(){v(this)}hasEvenY(){const{y:t}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(t)}equals(t){m(t);const{X:e,Y:n,Z:o}=this,{X:i,Y:s,Z:a}=t,c=r.eql(r.mul(e,a),r.mul(i,o)),u=r.eql(r.mul(n,a),r.mul(s,o));return c&&u}negate(){return new Point(this.X,r.neg(this.Y),this.Z)}double(){const{a:t,b:e}=i,n=r.mul(e,Wt),{X:o,Y:s,Z:a}=this;let c=r.ZERO,u=r.ZERO,l=r.ZERO,h=r.mul(o,o),f=r.mul(s,s),d=r.mul(a,a),g=r.mul(o,s);return g=r.add(g,g),l=r.mul(o,a),l=r.add(l,l),c=r.mul(t,l),u=r.mul(n,d),u=r.add(c,u),c=r.sub(f,u),u=r.add(f,u),u=r.mul(c,u),c=r.mul(g,c),l=r.mul(n,l),d=r.mul(t,d),g=r.sub(h,d),g=r.mul(t,g),g=r.add(g,l),l=r.add(h,h),h=r.add(l,h),h=r.add(h,d),h=r.mul(h,g),u=r.add(u,h),d=r.mul(s,a),d=r.add(d,d),h=r.mul(d,g),c=r.sub(c,h),l=r.mul(d,f),l=r.add(l,l),l=r.add(l,l),new Point(c,u,l)}add(t){m(t);const{X:e,Y:n,Z:o}=this,{X:s,Y:a,Z:c}=t;let u=r.ZERO,l=r.ZERO,h=r.ZERO;const f=i.a,d=r.mul(i.b,Wt);let g=r.mul(e,s),p=r.mul(n,a),y=r.mul(o,c),w=r.add(e,n),b=r.add(s,a);w=r.mul(w,b),b=r.add(g,p),w=r.sub(w,b),b=r.add(e,o);let E=r.add(s,c);return b=r.mul(b,E),E=r.add(g,y),b=r.sub(b,E),E=r.add(n,o),u=r.add(a,c),E=r.mul(E,u),u=r.add(p,y),E=r.sub(E,u),h=r.mul(f,b),u=r.mul(d,y),h=r.add(u,h),u=r.sub(p,h),h=r.add(p,h),l=r.mul(u,h),p=r.add(g,g),p=r.add(p,g),y=r.mul(f,y),b=r.mul(d,b),p=r.add(p,y),y=r.sub(g,y),y=r.mul(f,y),b=r.add(b,y),g=r.mul(p,b),l=r.add(l,g),g=r.mul(E,b),u=r.mul(w,u),u=r.sub(u,g),g=r.mul(w,p),h=r.mul(E,h),h=r.add(h,g),new Point(u,l,h)}subtract(t){return this.add(t.negate())}is0(){return this.equals(Point.ZERO)}multiply(t){const{endo:n}=e;if(!o.isValidNot0(t))throw new Error("invalid scalar: out of range");let r,i;const s=t=>P.cached(this,t,t=>Lt(Point,t));if(n){const{k1neg:e,k1:o,k2neg:a,k2:c}=b(t),{p:u,f:l}=s(o),{p:h,f:f}=s(c);i=l.add(f),r=A(n.beta,u,h,e,a)}else{const{p:e,f:n}=s(t);r=e,i=n}return Lt(Point,[r,i])[0]}multiplyUnsafe(t){const{endo:n}=e,r=this;if(!o.isValid(t))throw new Error("invalid scalar: out of range");if(t===$t||r.is0())return Point.ZERO;if(t===Yt)return r;if(P.hasCache(this))return this.multiply(t);if(n){const{k1neg:e,k1:o,k2neg:i,k2:s}=b(t),{p1:a,p2:c}=function(t,e,n,r){let o=e,i=t.ZERO,s=t.ZERO;for(;n>Ht||r>Ht;)n&Ct&&(i=i.add(o)),r&Ct&&(s=s.add(o)),o=o.double(),n>>=Ct,r>>=Ct;return{p1:i,p2:s}}(Point,r,o,s);return A(n.beta,a,c,e,i)}return P.unsafe(r,t)}multiplyAndAddUnsafe(t,e,n){const r=this.multiplyUnsafe(e).add(t.multiplyUnsafe(n));return r.is0()?void 0:r}toAffine(t){return E(this,t)}isTorsionFree(){const{isTorsionFree:t}=e;return s===Yt||(t?t(Point,this):P.unsafe(this,a).is0())}clearCofactor(){const{clearCofactor:t}=e;return s===Yt?this:t?t(Point,this):this.multiplyUnsafe(s)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}toBytes(t=!0){return F(t,"isCompressed"),this.assertValidity(),h(Point,this,t)}toHex(t=!0){return B(this.toBytes(t))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(t=!0){return this.toBytes(t)}_setWindowSize(t){this.precompute(t)}static normalizeZ(t){return Lt(Point,t)}static msm(t,e){return Dt(Point,o,t,e)}static fromPrivateKey(t){return Point.BASE.multiply(Qt(o,t))}}Point.BASE=new Point(i.Gx,i.Gy,r.ONE),Point.ZERO=new Point(r.ZERO,r.ONE,r.ZERO),Point.Fp=r,Point.Fn=o;const x=o.BITS,P=new wNAF(Point,e.endo?Math.ceil(x/2):x);return Point.BASE.precompute(8),Point}function ee(t){return Uint8Array.of(t?2:3)}function ne(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function re(t,e={}){const{Fn:n}=t,r=e.randomBytes||q,o=Object.assign(ne(t.Fp,n),{seed:Rt(n.ORDER)});function i(t){try{return!!Qt(n,t)}catch(e){return!1}}function s(t=r(o.seed)){return function(t,e,n=!1){const r=t.length,o=It(e),i=Rt(e);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const s=wt(n?Z(t):_(t),e-ct)+ct;return n?z(s,o):M(s,o)}(V(t,o.seed,"seed"),n.ORDER)}function a(e,r=!0){return t.BASE.multiply(Qt(n,e)).toBytes(r)}function c(e){if("bigint"==typeof e)return!1;if(e instanceof t)return!0;const{secretKey:r,publicKey:i,publicKeyUncompressed:s}=o;if(n.allowedLengths||r===i)return;const a=G("key",e).length;return a===i||a===s}const u={isValidSecretKey:i,isValidPublicKey:function(e,n){const{publicKey:r,publicKeyUncompressed:i}=o;try{const o=e.length;return(!0!==n||o===r)&&((!1!==n||o===i)&&!!t.fromBytes(e))}catch(s){return!1}},randomSecretKey:s,isValidPrivateKey:i,randomPrivateKey:s,normPrivateKeyToScalar:t=>Qt(n,t),precompute:(e=8,n=t.BASE)=>n.precompute(e,!1)};return Object.freeze({getPublicKey:a,getSharedSecret:function(e,r,o=!0){if(!0===c(e))throw new Error("first arg must be private key");if(!1===c(r))throw new Error("second arg must be public key");const i=Qt(n,e);return t.fromHex(r).multiply(i).toBytes(o)},keygen:function(t){const e=s(t);return{secretKey:e,publicKey:a(e)}},Point:t,utils:u,lengths:o})}function oe(t,e,n={}){E(e),J(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=n.randomBytes||q,o=n.hmac||((t,...n)=>st(e,t,L(...n))),{Fp:i,Fn:s}=t,{ORDER:a,BITS:c}=s,{keygen:u,getPublicKey:l,getSharedSecret:h,utils:f,lengths:d}=re(t,n),g={prehash:!1,lowS:"boolean"==typeof n.lowS&&n.lowS,format:void 0,extraEntropy:!1},p="compact";function y(t){return t>a>>Yt}function m(t,e){if(!s.isValidNot0(e))throw new Error(`invalid signature ${t}: out of range 1..Point.Fn.ORDER`);return e}class Signature{constructor(t,e,n){this.r=m("r",t),this.s=m("s",e),null!=n&&(this.recovery=n),Object.freeze(this)}static fromBytes(t,e=p){let n;if(function(t,e){Mt(e);const n=d.signature;V(t,"compact"===e?n:"recovered"===e?n+1:void 0,`${e} signature`)}(t,e),"der"===e){const{r:e,s:n}=Gt.toSig(V(t));return new Signature(e,n)}"recovered"===e&&(n=t[0],e="compact",t=t.subarray(1));const r=s.BYTES,o=t.subarray(0,r),i=t.subarray(r,2*r);return new Signature(s.fromBytes(o),s.fromBytes(i),n)}static fromHex(t,e){return this.fromBytes(C(t),e)}addRecoveryBit(t){return new Signature(this.r,this.s,t)}recoverPublicKey(e){const n=i.ORDER,{r:r,s:o,recovery:c}=this;if(null==c||![0,1,2,3].includes(c))throw new Error("recovery id invalid");if(a*Xt<n&&c>1)throw new Error("recovery id is ambiguous for h>1 curve");const u=2===c||3===c?r+a:r;if(!i.isValid(u))throw new Error("recovery id 2 or 3 invalid");const l=i.toBytes(u),h=t.fromBytes(L(ee(!(1&c)),l)),f=s.inv(u),d=v(G("msgHash",e)),g=s.create(-d*f),p=s.create(o*f),y=t.BASE.multiplyUnsafe(g).add(h.multiplyUnsafe(p));if(y.is0())throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return y(this.s)}toBytes(t=p){if(Mt(t),"der"===t)return C(Gt.hexFromSig(this));const e=s.toBytes(this.r),n=s.toBytes(this.s);if("recovered"===t){if(null==this.recovery)throw new Error("recovery bit must be present");return L(Uint8Array.of(this.recovery),e,n)}return L(e,n)}toHex(t){return B(this.toBytes(t))}assertValidity(){}static fromCompact(t){return Signature.fromBytes(G("sig",t),"compact")}static fromDER(t){return Signature.fromBytes(G("sig",t),"der")}normalizeS(){return this.hasHighS()?new Signature(this.r,s.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return B(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return B(this.toBytes("compact"))}}const b=n.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=_(t),n=8*t.length-c;return n>0?e>>BigInt(n):e},v=n.bits2int_modN||function(t){return s.create(b(t))},A=W(c);function x(t){return Y("num < 2^"+c,t,$t,A),s.toBytes(t)}function P(t,n){return V(t,void 0,"message"),n?V(e(t),void 0,"prehashed message"):t}return Object.freeze({keygen:u,getPublicKey:l,getSharedSecret:h,utils:f,lengths:d,Point:t,sign:function(n,i,a={}){n=G("message",n);const{seed:c,k2sig:u}=function(e,n,o){if(["recovered","canonical"].some(t=>t in o))throw new Error("sign() legacy options not supported");const{lowS:i,prehash:a,extraEntropy:c}=zt(o,g);e=P(e,a);const u=v(e),l=Qt(s,n),h=[x(l),x(u)];if(null!=c&&!1!==c){const t=!0===c?r(d.secretKey):c;h.push(G("extraEntropy",t))}const f=L(...h),p=u;return{seed:f,k2sig:function(e){const n=b(e);if(!s.isValidNot0(n))return;const r=s.inv(n),o=t.BASE.multiply(n).toAffine(),a=s.create(o.x);if(a===$t)return;const c=s.create(r*s.create(p+a*l));if(c===$t)return;let u=(o.x===a?0:2)|Number(o.y&Yt),h=c;return i&&y(c)&&(h=s.neg(c),u^=1),new Signature(a,h,u)}}}(n,i,a);return function(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");const r=t=>new Uint8Array(t),o=t=>Uint8Array.of(t);let i=r(t),s=r(t),a=0;const c=()=>{i.fill(1),s.fill(0),a=0},u=(...t)=>n(s,i,...t),l=(t=r(0))=>{s=u(o(0),t),i=u(),0!==t.length&&(s=u(o(1),t),i=u())},h=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){i=u();const e=i.slice();n.push(e),t+=i.length}return L(...n)};return(t,e)=>{let n;for(c(),l(t);!(n=e(h()));)l();return c(),n}}(e.outputLen,s.BYTES,o)(c,u)},verify:function(e,n,r,o={}){const{lowS:i,prehash:a,format:c}=zt(o,g);if(r=G("publicKey",r),n=P(G("message",n),a),"strict"in o)throw new Error("options.strict was renamed to lowS");const u=void 0===c?function(t){let e;const n="string"==typeof t||w(t),r=!n&&null!==t&&"object"==typeof t&&"bigint"==typeof t.r&&"bigint"==typeof t.s;if(!n&&!r)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(r)e=new Signature(t.r,t.s);else if(n){try{e=Signature.fromBytes(G("sig",t),"der")}catch(o){if(!(o instanceof Gt.Err))throw o}if(!e)try{e=Signature.fromBytes(G("sig",t),"compact")}catch(i){return!1}}return e||!1}(e):Signature.fromBytes(G("sig",e),c);if(!1===u)return!1;try{const e=t.fromBytes(r);if(i&&u.hasHighS())return!1;const{r:o,s:a}=u,c=v(n),l=s.inv(a),h=s.create(c*l),f=s.create(o*l),d=t.BASE.multiplyUnsafe(h).add(e.multiplyUnsafe(f));if(d.is0())return!1;return s.create(d.x)===o}catch(l){return!1}},recoverPublicKey:function(t,e,n={}){const{prehash:r}=zt(n,g);return e=P(e,r),Signature.fromBytes(t,"recovered").recoverPublicKey(e).toBytes()},Signature:Signature,hash:e})}function ie(t){const{CURVE:e,curveOpts:n}=function(t){const e={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},n=t.Fp;let r=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(t=>Math.ceil(t/2)))):void 0;return{CURVE:e,curveOpts:{Fp:n,Fn:Ot(e.n,{BITS:t.nBitLength,allowedLengths:r,modFromBytes:t.wrapPrivateKey}),allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes}}}(t),r={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:e,curveOpts:n,hash:t.hash,ecdsaOpts:r}}
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
function se(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function ae(t,...e){if(!se(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function ce(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function ue(t,e){ae(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function le(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function he(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function fe(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function de(t){if("string"==typeof t)t=function(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}(t);else{if(!se(t))throw new Error("Uint8Array expected, got "+typeof t);t=pe(t)}return t}function ge(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),a=Number(n&i);t.setUint32(e+0,s,r),t.setUint32(e+4,a,r)}function pe(t){return Uint8Array.from(t)}const ye=16,we=new Uint8Array(16),me=le(we),be=(t,e,n,r)=>({s3:n<<31|r>>>1,s2:e<<31|n>>>1,s1:t<<31|e>>>1,s0:t>>>1^225<<24&-(1&(1&r))}),Ee=t=>(t>>>0&255)<<24|(t>>>8&255)<<16|(t>>>16&255)<<8|t>>>24&255;class GHASH{constructor(t,e){this.blockLen=ye,this.outputLen=ye,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,ae(t=de(t),16);const n=fe(t);let r=n.getUint32(0,!1),o=n.getUint32(4,!1),i=n.getUint32(8,!1),s=n.getUint32(12,!1);const a=[];for(let d=0;d<128;d++)a.push({s0:Ee(r),s1:Ee(o),s2:Ee(i),s3:Ee(s)}),({s0:r,s1:o,s2:i,s3:s}=be(r,o,i,s));const c=(u=e||1024)>65536?8:u>1024?4:2;var u;if(![1,2,4,8].includes(c))throw new Error("ghash: invalid window size, expected 2, 4 or 8");this.W=c;const l=128/c,h=this.windowSize=2**c,f=[];for(let d=0;d<l;d++)for(let t=0;t<h;t++){let e=0,n=0,r=0,o=0;for(let i=0;i<c;i++){if(!(t>>>c-i-1&1))continue;const{s0:s,s1:u,s2:l,s3:h}=a[c*d+i];e^=s,n^=u,r^=l,o^=h}f.push({s0:e,s1:n,s2:r,s3:o})}this.t=f}_updateBlock(t,e,n,r){t^=this.s0,e^=this.s1,n^=this.s2,r^=this.s3;const{W:o,t:i,windowSize:s}=this;let a=0,c=0,u=0,l=0;const h=(1<<o)-1;let f=0;for(const d of[t,e,n,r])for(let t=0;t<4;t++){const e=d>>>8*t&255;for(let t=8/o-1;t>=0;t--){const n=e>>>o*t&h,{s0:r,s1:d,s2:g,s3:p}=i[f*s+n];a^=r,c^=d,u^=g,l^=p,f+=1}}this.s0=a,this.s1=c,this.s2=u,this.s3=l}update(t){ce(this),ae(t=de(t));const e=le(t),n=Math.floor(t.length/ye),r=t.length%ye;for(let o=0;o<n;o++)this._updateBlock(e[4*o+0],e[4*o+1],e[4*o+2],e[4*o+3]);return r&&(we.set(t.subarray(n*ye)),this._updateBlock(me[0],me[1],me[2],me[3]),he(me)),this}destroy(){const{t:t}=this;for(const e of t)e.s0=0,e.s1=0,e.s2=0,e.s3=0}digestInto(t){ce(this),ue(t,this),this.finished=!0;const{s0:e,s1:n,s2:r,s3:o}=this,i=le(t);return i[0]=e,i[1]=n,i[2]=r,i[3]=o,t}digest(){const t=new Uint8Array(ye);return this.digestInto(t),this.destroy(),t}}class Polyval extends GHASH{constructor(t,e){ae(t=de(t));const n=function(t){t.reverse();const e=1&t[15];let n=0;for(let r=0;r<t.length;r++){const e=t[r];t[r]=e>>>1|n,n=(1&e)<<7}return t[0]^=225&-e,t}(pe(t));super(n,e),he(n)}update(t){t=de(t),ce(this);const e=le(t),n=t.length%ye,r=Math.floor(t.length/ye);for(let o=0;o<r;o++)this._updateBlock(Ee(e[4*o+3]),Ee(e[4*o+2]),Ee(e[4*o+1]),Ee(e[4*o+0]));return n&&(we.set(t.subarray(r*ye)),this._updateBlock(Ee(me[3]),Ee(me[2]),Ee(me[1]),Ee(me[0])),he(me)),this}digestInto(t){ce(this),ue(t,this),this.finished=!0;const{s0:e,s1:n,s2:r,s3:o}=this,i=le(t);return i[0]=e,i[1]=n,i[2]=r,i[3]=o,t.reverse()}}function ve(t){const e=(e,n)=>t(n,e.length).update(de(e)).digest(),n=t(new Uint8Array(16),0);return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=(e,n)=>t(e,n),e}const Ae=ve((t,e)=>new GHASH(t,e));ve((t,e)=>new Polyval(t,e));var xe=Object.defineProperty,Be=(t,e)=>{for(var n in e)xe(t,n,{get:e[n],enumerable:!0})},Pe=(t,e,n)=>(((t,e,n)=>{e in t?xe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n})(t,"symbol"!=typeof e?e+"":e,n),n),Se={};Be(Se,{EmptyArray:()=>Cn,arrayToHex:()=>bn,arrayToUtf8:()=>En,calculateSharedKey:()=>On,comparePublicKeyHex:()=>xn,compressPublicKeyHex:()=>yn,doDecrypt:()=>Ln,doEncrypt:()=>Tn,doSignature:()=>Nn,doVerifySignature:()=>qn,ecdh:()=>In,generateKeyPairHex:()=>pn,getHash:()=>jn,getPoint:()=>Kn,getPublicKeyFromPrivateKey:()=>Vn,getZ:()=>kn,hexToArray:()=>vn,initRNGPool:()=>Ke,leftPad:()=>mn,precomputePublicKey:()=>Fn,utf8ToHex:()=>wn,verifyPublicKey:()=>An});var Ue=BigInt(0),Oe=BigInt(1),Ie=BigInt(2);BigInt(3);var Re=class{constructor(t=null,e="00",n="00",r=""){this.tlv=t,this.t=e,this.l=n,this.v=r}getEncodedHex(){return this.tlv||(this.v=this.getValue(),this.l=this.getLength(),this.tlv=this.t+this.l+this.v),this.tlv}getLength(){const t=this.v.length/2;let e=t.toString(16);if(e.length%2==1&&(e="0"+e),t<128)return e;return(128+e.length/2).toString(16)+e}getValue(){return""}},He=class extends Re{constructor(t){super(),this.t="02",t&&(this.v=function(t){let e=t.toString(16);if("-"!==e[0])e.length%2==1?e="0"+e:e.match(/^[0-7]/)||(e="00"+e);else{e=e.substring(1);let n=e.length;n%2==1?n+=1:e.match(/^[0-7]/)||(n+=2);let r="";for(let t=0;t<n;t++)r+="f";e=((rt(r)^t)+Oe).toString(16).replace(/^-/,"")}return e}(t))}getValue(){return this.v}},Ce=class extends Re{constructor(t){super(),this.s=t,Pe(this,"hV",""),this.t="04",t&&(this.v=t.toLowerCase())}getValue(){return this.v}},Te=class extends Re{constructor(t){super(),this.asn1Array=t,Pe(this,"t","30")}getValue(){return this.v=this.asn1Array.map(t=>t.getEncodedHex()).join(""),this.v}};function Le(t,e){if(+t[e+2]<8)return 1;const n=t.slice(e+2,e+6).slice(0,2);return 2*(parseInt(n,16)-128)}function Ne(t,e){const n=Le(t,e),r=t.substring(e+2,e+2+2*n);if(!r)return-1;return+(+r[0]<8?rt(r):rt(r.substring(2))).toString()}function qe(t,e){return e+2*(Le(t,e)+1)}function ke(t,e,n,r){const o=new He(t),i=new He(e),s=new Ce(n),a=new Ce(r);return new Te([o,i,s,a]).getEncodedHex()}var je,Fe=16384,Ve=new Uint8Array(0);async function Ke(){if("crypto"in globalThis)je=globalThis.crypto;else if(!(Ve.length>Fe/2))if("wx"in globalThis&&"getRandomValues"in globalThis.wx)Ve=await new Promise(t=>{wx.getRandomValues({length:Fe,success(e){t(new Uint8Array(e.randomValues))}})});else try{if(globalThis.crypto)je=globalThis.crypto;else{const t=await Promise.resolve().then(()=>ar);je=t.webcrypto}const t=new Uint8Array(Fe);je.getRandomValues(t),Ve=t}catch(t){throw new Error("no available csprng, abort.")}}Ke();var De=t=>t instanceof Uint8Array,_e=t=>new DataView(t.buffer,t.byteOffset,t.byteLength);if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");var Ze=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Me(t){if(!De(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Ze[t[n]];return e}var ze="undefined"!=typeof TextEncoder&&new TextEncoder,Ge=(t,e,n)=>((null==n||n>t.length)&&(n=t.length),new Uint8Array(t.subarray(e,n)));function $e(t){if(ze)return ze.encode(t);const e=t.length;let n=new Uint8Array(t.length+(t.length>>1)),r=0;const o=t=>{n[r++]=t};for(let i=0;i<e;++i){if(r+5>n.length){const t=new Uint8Array(r+8+(e-i<<1));t.set(n),n=t}let s=t.charCodeAt(i);s<128?o(s):s<2048?(o(192|s>>6),o(128|63&s)):s>55295&&s<57344?(s=65536+(1047552&s)|1023&t.charCodeAt(++i),o(240|s>>18),o(128|s>>12&63),o(128|s>>6&63),o(128|63&s)):(o(224|s>>12),o(128|s>>6&63),o(128|63&s))}return Ge(n,0,r)}function Ye(t){if("string"==typeof t&&(t=$e(t)),!De(t))throw new Error("expected Uint8Array, got "+typeof t);return t}var Xe=class{clone(){return this._cloneInto()}};var We=(t,e,n)=>t&e|t&n|e&n,Je=(t,e,n)=>t^e^n,Qe=(t,e,n)=>t&e|~t&n;function tn(t,e){const n=31&e;return t<<n|t>>>32-n}function en(t){return t^tn(t,9)^tn(t,17)}function nn(t){return t^tn(t,15)^tn(t,23)}var rn=class extends Xe{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,Pe(this,"buffer"),Pe(this,"view"),Pe(this,"finished",!1),Pe(this,"length",0),Pe(this,"pos",0),Pe(this,"destroyed",!1),this.buffer=new Uint8Array(t),this.view=_e(this.buffer)}update(t){const{view:e,buffer:n,blockLen:r}=this,o=(t=Ye(t)).length;for(let i=0;i<o;){const s=Math.min(r-this.pos,o-i);if(s===r){const e=_e(t);for(;r<=o-i;i+=r)this.process(e,i);continue}n.set(t.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===r&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){this.finished=!0;const{buffer:e,view:n,blockLen:r,isLE:o}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>r-i&&(this.process(n,0),i=0);for(let l=i;l<r;l++)e[l]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),a=Number(n&i),c=r?4:0,u=r?0:4;t.setUint32(e+c,s,r),t.setUint32(e+u,a,r)}(n,r-8,BigInt(8*this.length),o),this.process(n,0);const s=_e(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,u=this.get();if(c>u.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<c;l++)s.setUint32(4*l,u[l],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:i,pos:s}=this;return t.length=r,t.pos=s,t.finished=o,t.destroyed=i,r%e&&t.buffer.set(n),t}},on=new Uint32Array([1937774191,1226093241,388252375,3666478592,2842636476,372324522,3817729613,2969243214]),sn=new Uint32Array(68),an=new Uint32Array(64),cn=class extends rn{constructor(){super(64,32,8,!1),Pe(this,"A",0|on[0]),Pe(this,"B",0|on[1]),Pe(this,"C",0|on[2]),Pe(this,"D",0|on[3]),Pe(this,"E",0|on[4]),Pe(this,"F",0|on[5]),Pe(this,"G",0|on[6]),Pe(this,"H",0|on[7])}get(){const{A:t,B:e,C:n,D:r,E:o,F:i,G:s,H:a}=this;return[t,e,n,r,o,i,s,a]}set(t,e,n,r,o,i,s,a){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(t,e){for(let l=0;l<16;l++,e+=4)sn[l]=t.getUint32(e,!1);for(let l=16;l<68;l++)sn[l]=nn(sn[l-16]^sn[l-9]^tn(sn[l-3],15))^tn(sn[l-13],7)^sn[l-6];for(let l=0;l<64;l++)an[l]=sn[l]^sn[l+4];let{A:n,B:r,C:o,D:i,E:s,F:a,G:c,H:u}=this;for(let l=0;l<64;l++){let t=l>=0&&l<=15,e=t?2043430169:2055708042,h=tn(tn(n,12)+s+tn(e,l),7),f=h^tn(n,12),d=(t?Je(n,r,o):We(n,r,o))+i+f+an[l]|0,g=(t?Je(s,a,c):Qe(s,a,c))+u+h+sn[l]|0;i=o,o=tn(r,9),r=n,n=d,u=c,c=tn(a,19),a=s,s=en(g)}n=n^this.A|0,r=r^this.B|0,o=o^this.C|0,i=i^this.D|0,s=s^this.E|0,a=a^this.F|0,c=c^this.G|0,u=u^this.H|0,this.set(n,r,o,i,s,a,c,u)}roundClean(){sn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}},un=function(t){const e=e=>t().update(Ye(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}(()=>new cn),ln=class extends Xe{constructor(t,e){super(),Pe(this,"oHash"),Pe(this,"iHash"),Pe(this,"blockLen"),Pe(this,"outputLen"),Pe(this,"finished",!1),Pe(this,"destroyed",!1);const n=Ye(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,o=new Uint8Array(r);o.set(n.length>r?t.create().update(n).digest():n);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=t.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(t){return this.iHash.update(t),this}digestInto(t){this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=r,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},hn=(t,e,n)=>new ln(t,e).update(n).digest();hn.create=(t,e)=>new ln(t,e);var fn=Ot(BigInt("115792089210356248756420345214020892766250353991924191454421193933289684991999")),dn=function(t){const{CURVE:e,curveOpts:n,hash:r,ecdsaOpts:o}=ie(t);return function(t,e){const n=e.Point;return Object.assign({},e,{ProjectivePoint:n,CURVE:Object.assign({},t,Ut(n.Fn.ORDER,n.Fn.BITS))})}(t,oe(te(e,n),r,o))}({a:BigInt("115792089210356248756420345214020892766250353991924191454421193933289684991996"),b:BigInt("18505919022281880113072981827955639221458448578012075254857346196103069175443"),Fp:fn,h:Oe,n:BigInt("115792089210356248756420345214020892766061623724957744567843809356293439045923"),Gx:BigInt("22963146547237050559479531362550074578802567295341616970375194840604139615431"),Gy:BigInt("85132369209828568825618990617112496413088388631904505083283536607588877201568"),hash:un,hmac:(t,...e)=>hn(un,t,et(...e)),randomBytes:function(t=0){const e=new Uint8Array(t);if(je)return je.getRandomValues(e);{const e=function(t){if(Ve.length>t){const e=Ve.slice(0,t);return Ve=Ve.slice(t),Ke(),e}throw new Error("random number pool is not ready or insufficient, prevent getting too long random values or too often.")}(t);return e}}}),gn=Ot(BigInt(dn.CURVE.n));function pn(t){const e=t?ot(wt(BigInt(t),Oe)+Oe,32):dn.utils.randomPrivateKey(),n=dn.getPublicKey(e,!1);return{privateKey:mn(tt(e),64),publicKey:mn(tt(n),64)}}function yn(t){if(130!==t.length)throw new Error("Invalid public key to compress");const e=(t.length-2)/2,n=t.substring(2,2+e);let r="03";return wt(rt(t.substring(e+2,e+e+2)),Ie)===Ue&&(r="02"),r+n}function wn(t){const e=$e(t);return tt(e)}function mn(t,e){return t.length>=e?t:new Array(e-t.length+1).join("0")+t}function bn(t){return t.map(t=>{const e=t.toString(16);return 1===e.length?"0"+e:e}).join("")}function En(t){const e=[];for(let n=0,r=t.length;n<r;n++)t[n]>=240&&t[n]<=247?(e.push(String.fromCodePoint(((7&t[n])<<18)+((63&t[n+1])<<12)+((63&t[n+2])<<6)+(63&t[n+3]))),n+=3):t[n]>=224&&t[n]<=239?(e.push(String.fromCodePoint(((15&t[n])<<12)+((63&t[n+1])<<6)+(63&t[n+2]))),n+=2):t[n]>=192&&t[n]<=223?(e.push(String.fromCodePoint(((31&t[n])<<6)+(63&t[n+1]))),n++):e.push(String.fromCodePoint(t[n]));return e.join("")}function vn(t){let e=t.length;e%2!=0&&(t=mn(t,e+1)),e=t.length;const n=e/2,r=new Uint8Array(n);for(let o=0;o<n;o++)r[o]=parseInt(t.substring(2*o,2*o+2),16);return r}function An(t){const e=dn.ProjectivePoint.fromHex(t);if(!e)return!1;try{return e.assertValidity(),!0}catch(n){return!1}}function xn(t,e){const n=dn.ProjectivePoint.fromHex(t);if(!n)return!1;const r=dn.ProjectivePoint.fromHex(e);return!!r&&n.equals(r)}function Bn(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t.codePointAt(n);if(r<=127)e.push(r);else if(r<=2047)e.push(192|r>>>6),e.push(128|63&r);else if(r<=55295||r>=57344&&r<=65535)e.push(224|r>>>12),e.push(128|r>>>6&63),e.push(128|63&r);else{if(!(r>=65536&&r<=1114111))throw e.push(r),new Error("input is not supported");n++,e.push(240|r>>>18&28),e.push(128|r>>>12&63),e.push(128|r>>>6&63),e.push(128|63&r)}}return new Uint8Array(e)}function Pn(t,e,n){t="string"==typeof t?Bn(t):t;const r=Cn;let o=new Uint8Array(e),i=1,s=0,a=Cn;const c=new Uint8Array(4),u=()=>{c[0]=i>>24&255,c[1]=i>>16&255,c[2]=i>>8&255,c[3]=255&i,a=un(et(t,c,r)),i++,s=0};u();for(let l=0,h=o.length;l<h;l++)s===a.length&&u(),o[l]=255&a[s++];return o}var Sn=rt("80000000000000000000000000000000"),Un=rt("7fffffffffffffffffffffffffffffff");function On(t,e,n,r,o,i=!1,s="1234567812345678",a="1234567812345678"){const c=dn.ProjectivePoint.fromHex(e.publicKey),u=dn.ProjectivePoint.fromHex(r),l=dn.ProjectivePoint.fromHex(n);let h=kn(t.publicKey,s),f=kn(n,a);i&&([h,f]=[f,h]);const d=rt(e.privateKey),g=rt(t.privateKey),p=c.x,y=Sn+(p&Un),w=gn.add(g,gn.mulN(y,d)),m=u.x,b=gn.add(Sn,m&Un),E=u.multiply(b).add(l).multiply(w),v=vn(mn(nt(E.x),64)),A=vn(mn(nt(E.y),64));return Pn(et(v,A,h,f),o)}var{getSharedSecret:In}=dn;function Rn(t,e,n){const r=Pn(et(t,e),n.length);for(let o=0,i=n.length;o<i;o++)n[o]^=255&r[o]}var Hn=0,Cn=new Uint8Array;function Tn(t,e,n=1,r){const o="string"==typeof t?vn(wn(t)):Uint8Array.from(t),i="string"==typeof e?dn.ProjectivePoint.fromHex(e):e,s=pn(),a=rt(s.privateKey);let c=s.publicKey;c.length>128&&(c=c.substring(c.length-128));const u=i.multiply(a),l=vn(mn(nt(u.x),64)),h=vn(mn(nt(u.y),64)),f=Me(un(et(l,o,h)));Rn(l,h,o);const d=Me(o);if(r?.asn1){const t=dn.ProjectivePoint.fromHex(s.publicKey);return n===Hn?ke(t.x,t.y,d,f):ke(t.x,t.y,f,d)}return n===Hn?c+d+f:c+f+d}function Ln(t,e,n=1,r){const{output:o="string",asn1:i=!1}=r||{},s=rt(e);let a,c,u;if(i){const{x:e,y:r,cipher:o,hash:i}=function(t){function e(t,e){const n=qe(t,e),r=Ne(t,e),o=t.substring(n,n+2*r);return{value:o,nextStart:n+o.length}}const n=qe(t,0),{value:r,nextStart:o}=e(t,n),{value:i,nextStart:s}=e(t,o),{value:a,nextStart:c}=e(t,s),{value:u}=e(t,c);return{x:rt(r),y:rt(i),hash:a,cipher:u}}(t);a=dn.ProjectivePoint.fromAffine({x:e,y:r}),u=i,c=o,n===Hn&&([c,u]=[u,c])}else a=dn.ProjectivePoint.fromHex("04"+t.substring(0,128)),u=t.substring(128,192),c=t.substring(192),n===Hn&&(u=t.substring(t.length-64),c=t.substring(128,t.length-64));const l=vn(c),h=a.multiply(s),f=vn(mn(nt(h.x),64)),d=vn(mn(nt(h.y),64));Rn(f,d,l);return bn(Array.from(un(et(f,l,d))))===u.toLowerCase()?"array"===o?l:En(l):"array"===o?[]:""}function Nn(t,e,n={}){let{pointPool:r,der:o,hash:i,publicKey:s,userId:a}=n,c="string"==typeof t?wn(t):bn(Array.from(t));i&&(s=s||Vn(e),c=jn(c,s,a));const u=rt(e),l=rt(c);let h=null,f=null,d=null;do{do{let t;t=r&&r.length?r.pop():Kn(),h=t.k,f=gn.add(l,t.x1)}while(f===Ue||f+h===dn.CURVE.n);d=gn.mul(gn.inv(gn.addN(u,Oe)),gn.subN(h,gn.mulN(f,u)))}while(d===Ue);return o?function(t,e){const n=new He(t),r=new He(e);return new Te([n,r]).getEncodedHex()}(f,d):mn(nt(f),64)+mn(nt(d),64)}function qn(t,e,n,r={}){let o;const{hash:i,der:s,userId:a}=r,c="string"==typeof n?n:n.toHex(!1);let u,l;if(o=i?jn("string"==typeof t?wn(t):t,c,a):"string"==typeof t?wn(t):bn(Array.from(t)),s){const t=function(t){const e=qe(t,0),n=qe(t,e),r=Ne(t,e),o=t.substring(n,n+2*r),i=n+o.length,s=qe(t,i),a=Ne(t,i),c=t.substring(s,s+2*a);return{r:rt(o),s:rt(c)}}(e);u=t.r,l=t.s}else u=rt(e.substring(0,64)),l=rt(e.substring(64));const h="string"==typeof n?dn.ProjectivePoint.fromHex(n):n,f=rt(o),d=gn.add(u,l);if(d===Ue)return!1;const g=dn.ProjectivePoint.BASE.multiply(l).add(h.multiply(d));return u===gn.add(f,g.x)}function kn(t,e="1234567812345678"){e=wn(e);const n=mn(nt(dn.CURVE.a),64),r=mn(nt(dn.CURVE.b),64),o=mn(nt(dn.ProjectivePoint.BASE.x),64),i=mn(nt(dn.ProjectivePoint.BASE.y),64);let s,a;if(128===t.length)s=t.substring(0,64),a=t.substring(64,128);else{const e=dn.ProjectivePoint.fromHex(t);s=mn(nt(e.x),64),a=mn(nt(e.y),64)}const c=vn(e+n+r+o+i+s+a),u=4*e.length;return un(et(new Uint8Array([u>>8&255,255&u]),c))}function jn(t,e,n="1234567812345678"){const r=kn(e,n);return Me(un(et(r,"string"==typeof t?vn(t):t)))}function Fn(t,e){const n=dn.ProjectivePoint.fromHex(t);return dn.utils.precompute(e,n)}function Vn(t){const e=dn.getPublicKey(t,!1);return mn(tt(e),64)}function Kn(){const t=pn(),e=dn.ProjectivePoint.fromHex(t.publicKey),n=rt(t.privateKey);return{...t,k:n,x1:e.x}}var Dn={};Be(Dn,{decrypt:()=>er,encrypt:()=>tr,sm4:()=>Qn});var _n=0,Zn=32,Mn=16,zn=Uint8Array.from([214,144,233,254,204,225,61,183,22,182,20,194,40,251,44,5,43,103,154,118,42,190,4,195,170,68,19,38,73,134,6,153,156,66,80,244,145,239,152,122,51,84,11,67,237,207,172,98,228,179,28,169,201,8,232,149,128,223,148,250,117,143,63,166,71,7,167,252,243,115,23,186,131,89,60,25,230,133,79,168,104,107,129,178,113,100,218,139,248,235,15,75,112,86,157,53,30,36,14,94,99,88,209,162,37,34,124,59,1,33,120,135,212,0,70,87,159,211,39,82,76,54,2,231,160,196,200,158,234,191,138,210,64,199,56,181,163,247,242,206,249,97,21,161,224,174,93,164,155,52,26,85,173,147,50,48,245,140,177,227,29,246,226,46,130,102,202,96,192,41,35,171,13,83,78,111,213,219,55,69,222,253,142,47,3,255,106,114,109,108,91,81,141,27,175,146,187,221,188,127,17,217,92,65,31,16,90,216,10,193,49,136,165,205,123,189,45,116,208,18,184,229,180,176,137,105,151,74,12,150,119,126,101,185,241,9,197,110,198,132,24,240,125,236,58,220,77,32,121,238,95,62,215,203,57,72]),Gn=new Uint32Array([462357,472066609,943670861,1415275113,1886879365,2358483617,2830087869,3301692121,3773296373,4228057617,404694573,876298825,1347903077,1819507329,2291111581,2762715833,3234320085,3705924337,4177462797,337322537,808926789,1280531041,1752135293,2223739545,2695343797,3166948049,3638552301,4110090761,269950501,741554753,1213159005,1684763257]);function $n(t){return(255&zn[t>>>24&255])<<24|(255&zn[t>>>16&255])<<16|(255&zn[t>>>8&255])<<8|255&zn[255&t]}function Yn(t,e,n){let r=0,o=0,i=0,s=0,a=0,c=0,u=0,l=0;a=255&t[0],c=255&t[1],u=255&t[2],l=255&t[3],r=a<<24|c<<16|u<<8|l,a=255&t[4],c=255&t[5],u=255&t[6],l=255&t[7],o=a<<24|c<<16|u<<8|l,a=255&t[8],c=255&t[9],u=255&t[10],l=255&t[11],i=a<<24|c<<16|u<<8|l,a=255&t[12],c=255&t[13],u=255&t[14],l=255&t[15],s=a<<24|c<<16|u<<8|l;for(let h=0;h<32;h+=4)a=o^i^s^n[h],a=$n(a),r^=a^(a<<2|a>>>30)^(a<<10|a>>>22)^(a<<18|a>>>14)^(a<<24|a>>>8),c=i^s^r^n[h+1],c=$n(c),o^=c^(c<<2|c>>>30)^(c<<10|c>>>22)^(c<<18|c>>>14)^(c<<24|c>>>8),u=s^r^o^n[h+2],u=$n(u),i^=u^(u<<2|u>>>30)^(u<<10|u>>>22)^(u<<18|u>>>14)^(u<<24|u>>>8),l=r^o^i^n[h+3],l=$n(l),s^=l^(l<<2|l>>>30)^(l<<10|l>>>22)^(l<<18|l>>>14)^(l<<24|l>>>8);e[0]=s>>>24&255,e[1]=s>>>16&255,e[2]=s>>>8&255,e[3]=255&s,e[4]=i>>>24&255,e[5]=i>>>16&255,e[6]=i>>>8&255,e[7]=255&i,e[8]=o>>>24&255,e[9]=o>>>16&255,e[10]=o>>>8&255,e[11]=255&o,e[12]=r>>>24&255,e[13]=r>>>16&255,e[14]=r>>>8&255,e[15]=255&r}function Xn(t,e,n){let r=0,o=0,i=0,s=0,a=0;r=(255&t[0])<<24|(255&t[1])<<16|(255&t[2])<<8|255&t[3],o=(255&t[4])<<24|(255&t[5])<<16|(255&t[6])<<8|255&t[7],i=(255&t[8])<<24|(255&t[9])<<16|(255&t[10])<<8|255&t[11],s=(255&t[12])<<24|(255&t[13])<<16|(255&t[14])<<8|255&t[15],r^=2746333894,o^=1453994832,i^=1736282519,s^=2993693404;for(let c=0;c<32;c+=4)a=o^i^s^Gn[c+0],a=$n(a),r^=a^(a<<13|a>>>19)^(a<<23|a>>>9),e[c+0]=r,a=i^s^r^Gn[c+1],a=$n(a),o^=a^(a<<13|a>>>19)^(a<<23|a>>>9),e[c+1]=o,a=s^r^o^Gn[c+2],a=$n(a),i^=a^(a<<13|a>>>19)^(a<<23|a>>>9),e[c+2]=i,a=r^o^i^Gn[c+3],a=$n(a),s^=a^(a<<13|a>>>19)^(a<<23|a>>>9),e[c+3]=s;if(n===_n)for(let c=0;c<16;c++)[e[c],e[31-c]]=[e[31-c],e[c]]}function Wn(t){for(let e=t.length-1;e>=0&&(t[e]++,0===t[e]);e--);}var Jn=new Uint8Array(16);function Qn(t,e,n,r={}){let{padding:o="pkcs#7",mode:i,iv:s=new Uint8Array(16),output:a,associatedData:c,outputTag:u,tag:l}=r;if("gcm"===i){const r="string"==typeof e?vn(e):Uint8Array.from(e),o="string"==typeof s?vn(s):Uint8Array.from(s),i=c?"string"==typeof c?vn(c):Uint8Array.from(c):new Uint8Array(0);let h;h="string"==typeof t?n!==_n?Bn(t):vn(t):Uint8Array.from(t);const f=function(t,e,n,r,o,i){function s(t,e){const n=r.length,o=e.length,i=Ae.create(t);n>0&&i.update(r),i.update(e);const s=new Uint8Array(16),a=fe(s);return ge(a,0,BigInt(8*n),!1),ge(a,8,BigInt(8*o),!1),i.update(s),i.digest()}const{roundKey:a,h:c,counter:u,tagMask:l}=function(){const t=new Uint32Array(Zn);Xn(e,t,1);const r=new Uint8Array(16).fill(0),o=new Uint8Array(16);let i;if(Yn(r,o,t),12===n.length)i=new Uint8Array(16),i.set(n,0),i[15]=1;else{const t=Ae.create(o);t.update(n);const e=new Uint8Array(16);ge(fe(e),8,BigInt(8*n.length),!1),t.update(e),i=t.digest()}const s=new Uint8Array(i);Wn(s);const a=new Uint8Array(16);return Yn(i,a,t),{roundKey:t,h:o,j0:i,counter:s,tagMask:a}}();if(o===_n&&i){const e=s(c,t);for(let t=0;t<16;t++)e[t]^=l[t];let n=0;for(let t=0;t<16;t++)n|=e[t]^i[t];if(0!==n)throw new Error("authentication tag mismatch")}const h=new Uint8Array(t.length);let f=0,d=t.length;for(;d>=Mn;){const e=new Uint8Array(Mn);Yn(u,e,a);for(let n=0;n<Mn&&n<d;n++)h[f+n]=t[f+n]^e[n];Wn(u),f+=Mn,d-=Mn}if(d>0){const e=new Uint8Array(Mn);Yn(u,e,a);for(let n=0;n<d;n++)h[f+n]=t[f+n]^e[n]}if(o!==_n){const t=s(c,h);for(let e=0;e<16;e++)t[e]^=l[e];return{output:h,tag:t}}return{output:h}}(h,r,o,i,n,l?"string"==typeof l?vn(l):Uint8Array.from(l):void 0);return"array"===a?u&&n!==_n?f:f.output:u&&n!==_n||n!==_n?{output:Me(f.output),tag:f.tag?Me(f.tag):void 0}:En(f.output)}if("cbc"===i&&("string"==typeof s&&(s=vn(s)),16!==s.length))throw new Error("iv is invalid");if("string"==typeof e&&(e=vn(e)),16!==e.length)throw new Error("key is invalid");if(t="string"==typeof t?n!==_n?Bn(t):vn(t):Uint8Array.from(t),("pkcs#5"===o||"pkcs#7"===o)&&n!==_n){const e=Mn-t.length%Mn,n=new Uint8Array(t.length+e);n.set(t,0);for(let r=0;r<e;r++)n[t.length+r]=e;t=n}const h=new Uint32Array(Zn);Xn(e,h,n);let f=new Uint8Array(t.length),d=s,g=t.length,p=0;for(;g>=Mn;){const e=t.subarray(p,p+16);if("cbc"===i)for(let t=0;t<Mn;t++)n!==_n&&(e[t]^=d[t]);Yn(e,Jn,h);for(let t=0;t<Mn;t++)"cbc"===i&&n===_n&&(Jn[t]^=d[t]),f[p+t]=Jn[t];"cbc"===i&&(d=n!==_n?Jn:e),g-=Mn,p+=Mn}if(("pkcs#5"===o||"pkcs#7"===o)&&n===_n){const t=f.length,e=f[t-1];for(let n=1;n<=e;n++)if(f[t-n]!==e)throw new Error("padding is invalid");f=f.slice(0,t-e)}return"array"!==a?n!==_n?Me(f):En(f):f}function tr(t,e,n={}){return Qn(t,e,1,n)}function er(t,e,n={}){return Qn(t,e,0,n)}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */class SM2Utilities{static instance=new SM2Utilities;cipherMode=1;constructor(){}static getInstance(){return this.instance}createKeyPair(){return Se.generateKeyPairHex()}encrypt(t,e){return"04"+Se.doEncrypt(t,e,this.cipherMode)}decrypt(t,e){let n=t.substring(2).toLocaleLowerCase();return Se.doDecrypt(n,e,this.cipherMode,{output:"string"})}}class SM4Utilities{static instance=new SM4Utilities;constructor(){}static getInstance(){return this.instance}encrypt(t,e){return Dn.encrypt(t,e,{output:"string"})}decrypt(t,e){return Dn.decrypt(t,e,{output:"string"})}}const nr=SM2Utilities.getInstance(),rr=SM4Utilities.getInstance(),or=s.mixin({toast:!0,position:"top",showConfirmButton:!1,timer:2e3,timerProgressBar:!1,didOpen:t=>{t.addEventListener("mouseenter",s.stopTimer),t.addEventListener("mouseleave",s.resumeTimer)}});class Notify{static instance=new Notify;constructor(){}static getInstance(){return this.instance}information(t,e,n){return s.fire({title:t,text:e,position:"top",icon:n,timer:5e3,showConfirmButton:!1,showClass:{popup:"animate__animated animate__fadeIn"},hideClass:{popup:"animate__animated animate__fadeOut"}})}info(t,e=""){return this.information(t,e,"info")}error(t,e=""){return this.information(t,e,"error")}warning(t,e=""){return this.information(t,e,"warning")}success(t,e=""){return this.information(t,e,"success")}question(t,e=""){return this.information(t,e,"question")}}const ir=Notify.getInstance();class Toast{static instance=new Toast;constructor(){}static getInstance(){return this.instance}information(t,e){return or.fire({icon:e,title:t})}info(t){return this.information(t,"info")}error(t){return this.information(t,"error")}warning(t){return this.information(t,"warning")}success(t){return this.information(t,"success")}question(t){return this.information(t,"question")}}const sr=Toast.getInstance();a.locale("zh-cn");class Service{config;constructor(t){this.config=t}getConfig(){return this.config}getParamPath(t,e){return t+"/"+e}getIdPath(t){return this.getParamPath(this.getBaseAddress(),t)}}const ar=Object.freeze(Object.defineProperty({__proto__:null,default:{}},Symbol.toStringTag,{value:"Module"}));t.lodash=u,Object.defineProperty(t,"Base64",{enumerable:!0,get:()=>i.Base64}),t.Swal=s,t.moment=a,t.AvatarUtils=p,t.Axios=class Axios{axiosInstance;axiosConfig;axiosTransform;defaultRequestOptions;constructor(t,e,n){this.axiosConfig=t,this.axiosTransform=e,this.defaultRequestOptions=n,this.axiosInstance=this.createAxiosInstance(t),this.setupInterceptors()}createAxiosInstance(t){return e.create(t)}getAxiosConfig(){return this.axiosConfig}getAxiosTransform(){return this.axiosTransform}getAxiosInstance(){return this.axiosInstance}getDefaultRequestOptions(){return this.defaultRequestOptions}getPolicy(t){switch(t){case l.URL_ENCODED:return{headers:{"Content-Type":"application/x-www-form-urlencoded"},dataConvert:t=>n.stringify(t,{arrayFormat:"brackets"})};case l.MULTI_PART:return{headers:{"Content-Type":"multipart/form-data"},dataConvert:t=>t};default:return{headers:{"Content-Type":"application/json"},dataConvert:t=>JSON.stringify(t)}}}setupInterceptors(){const t=this.getAxiosTransform();if(!t)return;const{requestInterceptors:e,requestInterceptorsCatch:n,responseInterceptors:r,responseInterceptorsCatch:o}=t,i=new AxiosCanceler;this.getAxiosInstance().interceptors.request.use(t=>{const{prohibitRepeatRequests:n}=this.getDefaultRequestOptions();return n&&i.addPending(t),e(t)},t=>n(this.getAxiosInstance(),t)),this.getAxiosInstance().interceptors.response.use(t=>(t&&i.removePending(t.config),r(t)),t=>o(this.getAxiosInstance(),t))}mergeRequestOptions(t){const e=this.getDefaultRequestOptions();return r.isEmpty(t)?e:Object.assign({},e,t)}mergeRequestConfigs(t){const e=this.getAxiosConfig(),n={serialize:t=>Object.keys(t).map(e=>`${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`).join("&")},r=Object.assign({paramsSerializer:n},e);return t?Object.assign({},r,t):r}setupPolicy(t,e,n){const{beforeRequestHook:o}=this.getAxiosTransform(),i=this.mergeRequestOptions(e);let s=this.mergeRequestConfigs(n);o&&r.isFunction(o)&&(s=o(s,i));const a=i.contentType,c=this.getPolicy(a);return s.headers?s.headers=Object.assign(s.headers,c.headers):s.headers=c.headers,s.url=t,r.isEmpty(s.data)||(s.data=c.dataConvert(s.data)),{config:s,options:i,dataConvert:c.dataConvert}}get(t,e={},n={contentType:l.JSON}){let r=this.setupPolicy(t,n,{params:e,method:h.GET});return this.request(r.config,r.options)}post(t,e,n={contentType:l.JSON},r){let o=this.setupPolicy(t,n,{...r,data:e,method:h.POST});return this.request(o.config,o.options)}postWithParams(t,e={},n={},r={contentType:l.JSON},o){let i=this.setupPolicy(t,r,{...o,params:e,data:n,method:h.POST});return this.request(i.config,i.options)}put(t,e,n={contentType:l.JSON},r){let o=this.setupPolicy(t,n,{...r,data:e,method:h.PUT});return this.request(o.config,o.options)}putWithParams(t,e={},n={},r={contentType:l.JSON},o){let i=this.setupPolicy(t,r,{...o,params:e,data:n,method:h.PUT});return this.request(i.config,i.options)}delete(t,e={},n={contentType:l.JSON}){let r=this.setupPolicy(t,n,{data:e,method:h.DELETE});return this.request(r.config,r.options)}deleteWithParams(t,e={},n={},r={contentType:l.JSON}){let o=this.setupPolicy(t,r,{params:e,data:n,method:h.DELETE});return this.request(o.config,o.options)}request(t,e){return new Promise((n,o)=>{const{requestCatchHook:i,transformRequestHook:s}=this.getAxiosTransform();this.getAxiosInstance().request(t).then(t=>{if(s&&r.isFunction(s)){const r=s(t,e);n(r)}else n(t)}).catch(t=>{i&&r.isFunction(i)?o(i(t,e)):o(t)})})}},t.BaseService=class BaseService extends Service{getConditionAddress(){return this.getBaseAddress()+"/condition"}getListAddress(){return this.getBaseAddress()+"/list"}getTreeAddress(){return this.getBaseAddress()+"/tree"}fetch(t={}){return this.getConfig().getHttp().get(this.getBaseAddress(),t)}fetchByPage(t,e={}){if(r.isEmpty(e))return this.getConfig().getHttp().get(this.getBaseAddress(),t);{const n=Object.assign(t,e);return this.getConfig().getHttp().get(this.getConditionAddress(),n)}}fetchAll(t={}){return this.getConfig().getHttp().get(this.getListAddress(),t)}fetchTree(t={}){return this.getConfig().getHttp().get(this.getTreeAddress(),t)}saveOrUpdate(t){return this.getConfig().getHttp().post(this.getBaseAddress(),t)}delete(t){return this.getConfig().getHttp().delete(this.getIdPath(t))}assign(t){return this.getConfig().getHttp().put(this.getBaseAddress(),t,{contentType:l.URL_ENCODED})}},t.ContentTypeEnum=l,t.HttpConfig=class HttpConfig{http={};project="";clientId="";clientSecret="";oidc=!1;uaaAddress="";upmsAddress="";msgAddress="";ossAddress="";bpmnAddress="";cmdbAddress="";proxy="";constructor(t,e,n,r,o=!1,i="/api"){this.project=t,this.clientId=e,this.clientSecret=n,this.http=r,this.oidc=o,this.proxy=i,this.switch(t)}switch(t){switch(t){case"dante":this.uaaAddress="/dante-cloud-uaa",this.upmsAddress="/dante-cloud-upms",this.msgAddress="/dante-cloud-message",this.ossAddress="/dante-cloud-oss-ability",this.bpmnAddress="/dante-cloud-bpmn-ability/engine-rest",this.cmdbAddress="/dante-cloud-cmdb-ability";break;case"herodotus":this.uaaAddress="/herodotus-cloud-uaa",this.upmsAddress="/herodotus-cloud-upms",this.msgAddress="/herodotus-cloud-message",this.ossAddress="/herodotus-cloud-oss-ability",this.bpmnAddress="/herodotus-cloud-bpmn-ability/engine-rest",this.cmdbAddress="/herodotus-cloud-cmdb-ability";break;default:this.uaaAddress="",this.upmsAddress="",this.msgAddress="",this.ossAddress="",this.bpmnAddress="/engine-rest",this.cmdbAddress=""}}getProject(){return this.project}getClientSecret(){return this.clientSecret}getClientId(){return this.clientId}isOidc(){return this.oidc}getProxy(){return this.proxy}getHttp(){return this.http}processProxy(t,e=!0){return e?this.proxy+t:t}getUaa(t=!0){return this.processProxy(this.uaaAddress,t)}getUpms(t=!0){return this.processProxy(this.upmsAddress,t)}getMsg(t=!0){return this.processProxy(this.msgAddress,t)}getOss(t=!0){return this.processProxy(this.ossAddress,t)}getBpmn(t=!0,e=!1){let n=this.processProxy(this.bpmnAddress,t);return e?u.replace(n,"engine-rest","camunda-extended"):n}getCmdb(t=!0){return this.processProxy(this.cmdbAddress,t)}},t.HttpMethodEnum=h,t.SM2Utils=nr,t.SM4Utils=rr,t.Service=Service,t.StatusEnum=f,t.notify=ir,t.parseResponseStatus=(t,e)=>{const n=t.data,r={};return r.status=t.status,r.code=t.data&&t.data.code?t.data.code:0,r.detail=n.error&&n.error.detail?n.error.detail:"",n.message?r.message=n.message:n.error&&n.error.message?r.message=n.error.message:e&&(r.message=e),r},t.standardDeleteNotify=(t,e)=>{s.fire({title:"?",text:"",icon:"warning",showCancelButton:!0,confirmButtonColor:"#3085d6",cancelButtonColor:"#d33",confirmButtonText:", !",cancelButtonText:""}).then(n=>{n.value?t():e&&e()})},t.toast=sr,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});
